Четыре основных компонента Торнадо:
    веб-фреймворк (RequestHandler, который наследуется для создания веб-приложений, а также вспомогательные классы)
    реализации клиентской и серверной части HTTP (HTTPServer and AsyncHTTPClient)
    асинхронная сетевая библиотека (IOLoop and IOStream), которая служит основным строительным блоком HTTP компонент и может быть использована
        для реализации других протоколов
    библиотека coroutine (tornado.gen), с помощью которой можно писать асинхронный код проще и понятнее, чем используя цепочки кол-бэков

Торнадо фреймворк и HTTP server -- это альтернатива WSGI

Real-time web штукам нужно долгоживущее, почти всегда холостое соединение с пользователем. Синхронный веб-сервер для такого просто каждому
пользователю предоставляет один поток выполнения.
Чтобы минимизировать издержки одновременных соединений, Торнадо использует однопоточный event loop. Весь код должен быть асинхронным и
неблокирующим, так как может быть активна только одна операция в каждый момент времени.

Блокирующая функция -- ждем чего-то перед тем, как вернуть контроль вызвавшей программе.
Асинхронная функция -- возвращает контроль до того, как закончилось ее выполнений, запуская какую-то фоновую работу, а потом в будущем
запускает какое-то действие в будущем (обычная функция делает все, что нада, и возвращает контроль)


Структура веб-приложения

    RequestHandler subclasses
        Каждый обработчик определяет методы get(), post() etc.,которые будут вызваны в соответствии с методом запроса. Аргументы -- выцепленные группы в регулярных выражениях.
            RequestHandler.render or RequestHandler.write -- методы для создания ответа.
                render() загружает Template и передает его, заполнив полученными аргументами.
                write() используется для не-шаблонного вывода, принимает строки, байтсы и словари, которые будут закодированы в JSON.
        множество методов RequestHandler спроектированы, чтобы переопределить их в подклассах и использовать в приложении.
            често определяют класс BaseHandler, который переопределяет методы write_error and get_current_user, и дальше уже наследуют свои обработчики от него
        объект обработчика имеет доступ к текущему запросу self.request (see HTTPServerRequest)
        данные запроса из HTML форм доступны через методы get_query_argument and get_body_argument
        если вместо form-encoding я хочу использовать JSON, тогда мне надо переопределять метод prepare обработчика

        ЗАПРОС
        каждый запрос порождает следующую цепочку вызовов:
            создается экземпляр RequestHandler
            вызывается initialize() (сохраняет полученные аргументы в атрибуты экземпляра) с аргументами инициализации из настроек Application
            prepare() -- вызывается для запроса с любым HTTP методом, удобно переопределить в суперклассе. Если в нем вызывается либо finish(), redirect(), тогда процесс останавливается здесь
            вызывается соответствующий метод
            когда запрос обработан, вызвается on_finish(). Для синхронных обработчиков это происходит сразу после возврата из get() к примеру, для асинхронных -- после вызова finish()

        Error Handling, Redirection, Asynchronous Handlers

    Application object -- перенаправляет входящие запросы обработчикам
        отвечает за все глобальные настройки приложения
        содержит таблицу путей, которая сопоставляет запросам обработчики
            таблица путей -- это список объектов URLSpec (tuples = a regexp and a handler class)
                если в регулярном выражении есть выцепленые группы, тогда эти группы будут переданы HTTP методу обработчика
                если третим аргументом объекту URLSpec передается словарь, тогда он содержит аргументы инициализации, которые буду
                    переданы RequestHandler.initialize
                URLSpec может иметь имя, которое можно будет использовать в RequestHandler.reverse_url
        конструктору Application можно передавать множество именованый аргументов чтобы настроить приложение и включить дополнительные штуки (см. Application.settings)

    main() -- запуск сервера

User authentication
    set_secure_cookie, get_secure_cookie (в Application нужно указать дополнительный именованный аргумент cookie_secret). Signed cookies содержат
    закодированное значение, метку времени и HMAC подпись. Если куки устрарело, или не совпадает подпись, тогда get_secure_cookie вернет None.
    Автентифицированный пользователь доступен в каждом обработчике запроса self.current_user и в каждом шаблоне как current_user (default current_user is None)
    Чтобы реализовать проверку подленности пользователя, нужно переопределить метод get_current_user() в обработчике запроса, чтобы определять
    текущего пользователя по, скажем, значению cookie

    Можно также использовать декоратор tornado.web.authenticated(это просто альтернатива проверке self.current_user --> self.redirect). Если запрос попадает в сдекорированный метод, и пользователь не залогинен,
    тогда он будет перенаправлен на login_url -- еще одна настройка Application.


Running and deploying
торнадо предоставляет свой собственный HTTPServer
main() запускает сервер

